package info.ralab.uxdf.rdb;

import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import info.ralab.uxdf.UXDFException;
import info.ralab.uxdf.UXDFLoader;
import info.ralab.uxdf.chain.UXDFChain;
import info.ralab.uxdf.definition.SdEventDefinition;
import info.ralab.uxdf.definition.SdNodeDefinition;
import info.ralab.uxdf.definition.SdProperty;
import info.ralab.uxdf.instance.EventEntity;
import info.ralab.uxdf.instance.NodeEntity;
import info.ralab.uxdf.rdb.mapper.UXDFMapper;
import info.ralab.uxdf.rdb.model.RelationShipRdb;
import info.ralab.uxdf.rdb.model.RelationShipRdbTable;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.*;

@Component
@Slf4j
public class RdbLoader {

    private static final String DDL_SQL_SPLIT = "##";

    /**
     * 关系型数据库和SD之间的映射关系
     */
    private static RelationShipRdb CACHE_RDB_RELATION_SHIP = null;
    /**
     * Oracle数据库驱动名称
     */
    private static final String ORACLE_DATABASE_DRIVER = "oracle";
    /**
     * Mysql数据库驱动名称
     */
    private static final String MYSQL_DATABASE_DRIVER = "com.mysql";

    @Autowired
    private UXDFMapper uxdfMapper;
    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * Oracle Sql生成
     */
    @Autowired
    @Qualifier("oracleSqlGenerator")
    private SqlGenerator oracleSqlGenerator;

    /**
     * MySql Sql生成
     */
    @Autowired
    @Qualifier("mysqlSqlGenerator")
    private SqlGenerator mysqlSqlGenerator;

    /**
     * 数据源驱动类名称，通过application.properties获取
     */
    @Value("${spring.datasource.driver-class-name}")
    private String datasourceDriveName;

    /**
     * 是否自动生成DDL
     */
    @Value("${truedata.auto.generate.ddl}")
    private boolean autoGenerateDDL;

    /**
     * 根据application中数据库的驱动类型判断注入那个SQLGenerator
     *
     * @return
     */
    public SqlGenerator getSqlGenerator() {
        if (datasourceDriveName.startsWith(ORACLE_DATABASE_DRIVER)) {
            return oracleSqlGenerator;
        } else if (datasourceDriveName.startsWith(MYSQL_DATABASE_DRIVER)) {
            return mysqlSqlGenerator;
        } else {
            throw new UXDFException("无法根据数据库驱动注入SqlGenerator对象");
        }
    }

    /**
     * 获取Node和关系型数据库的对应关系
     *
     * @param nodeName
     * @return
     */
    public RelationShipRdbTable getRdbNodeMapping(final String nodeName) {
        this.load(false);
        return CACHE_RDB_RELATION_SHIP.getNode().get(nodeName);
    }

    /**
     * 获取Event和关系型数据库对应关系
     *
     * @param eventName
     * @return
     */
    public Map<String, Map<String, RelationShipRdbTable>> getRdbEventMapping(String eventName) {
        this.load(false);
        return CACHE_RDB_RELATION_SHIP.getEvent().get(eventName);
    }

    public RelationShipRdbTable getRdbEventMapping(
            String eventName,
            String leftNodeName,
            String rightNodeName
    ) {
        this.load(false);
        if (CACHE_RDB_RELATION_SHIP.getEvent().containsKey(eventName) &&
                CACHE_RDB_RELATION_SHIP.getEvent().get(eventName).containsKey(leftNodeName) &&
                CACHE_RDB_RELATION_SHIP.getEvent().get(eventName).get(leftNodeName).containsKey(rightNodeName)) {
            return CACHE_RDB_RELATION_SHIP.getEvent().get(eventName).get(leftNodeName).get(rightNodeName);
        } else {
            return null;
        }
    }

    /**
     * 获取所有缓存的关系
     *
     * @return
     */
    public RelationShipRdb getCacheRdbRelationShip() {
        this.load(false);
        return CACHE_RDB_RELATION_SHIP;
    }

    public void load(boolean force) {
        if (!force && CACHE_RDB_RELATION_SHIP != null) {
            return;
        }
        // 获取数据库映射关系
        CACHE_RDB_RELATION_SHIP = this.getSqlGenerator().generateRelationShip(UXDFLoader.getSd());

        // 设置数据环境变量
        this.uxdfMapper.setEnv();

        // 不自动生成DDL
        if (!autoGenerateDDL) {
            return;
        }

        // 检查ID分区表是否存在
        if (uxdfMapper.checkTableExists("ID_AREA") == null) {
            uxdfMapper.createIdArea();
        }

        // 基于SQL关系检查数据，并构建库表结构
        List<String> notExistsSd = Lists.newArrayList();
        CACHE_RDB_RELATION_SHIP.getNode().forEach((nodeName, relationShipRdbTable) -> {
            if (nodeName.startsWith("$")) {
                // 元数据定义不检查
                return;
            }
            String tableName = this.uxdfMapper.checkTableExists(relationShipRdbTable.getName());
            if (tableName == null) {
                notExistsSd.add(nodeName);
            }
        });
        CACHE_RDB_RELATION_SHIP.getEvent().forEach((eventName, leftMap) -> {
            if (eventName.startsWith("$")) {
                // 元数据定义不检查
                return;
            }
            leftMap.forEach((leftNodeName, rightMap) -> {
                rightMap.forEach((rightNodeName, relationShipRdbTable) -> {
                    String tableName = this.uxdfMapper.checkTableExists(relationShipRdbTable.getName());
                    if (tableName == null) {
                        notExistsSd.add(String.format(
                                "%s%s%s%s%s",
                                leftNodeName,
                                UXDFChain.PATH_LINE,
                                eventName,
                                UXDFChain.PATH_LEFT,
                                rightNodeName
                        ));
                    }
                });
            });
        });

        log.warn("not exists sd tables: {}", notExistsSd);


        if (!notExistsSd.isEmpty()) {
            // 构建SD，生成DDL
            String ddlSql = this.getSqlGenerator().generateDDL(UXDFLoader.getSd(), notExistsSd.toArray(new String[]{}));

            for (String sql : ddlSql.split(DDL_SQL_SPLIT)) {
                if (sql.trim().isEmpty()) {
                    continue;
                }
                log.info("ddl sql : {}", sql);
                this.jdbcTemplate.execute(sql);
            }
        }
    }

    /**
     * 生成node insert语句
     *
     * @param sdNode
     * @return
     */
    public String generateInsertSql(final SdNodeDefinition sdNode) {
        RelationShipRdbTable relation = this.getRdbNodeMapping(sdNode.getNodeName());
        return generateInsertSql(relation);
    }

    /**
     * 生成event insert语句
     *
     * @param sdEvent
     * @return
     */
    public String generateInsertSql(final SdEventDefinition sdEvent) {
        RelationShipRdbTable relation = this.getRdbEventMapping(
                sdEvent.getEventName(), sdEvent.getLeftNodeName(), sdEvent.getRightNodeName()
        );
        return generateInsertSql(relation);

    }

    private String generateInsertSql(RelationShipRdbTable relation) {

        // 获取表名
        final String tableName = relation.getName();
        // 字段名称
        List<String> columnNames = Lists.newArrayList(relation.getColumn().values());
        Collections.sort(columnNames);

        // 占位符
        String[] placeholders = new String[columnNames.size()];
        Arrays.fill(placeholders, "?");

        return String.format(
                "insert into %s (%s) values(%s)",
                tableName,
                Joiner.on(",").join(columnNames),
                Joiner.on(",").join(placeholders)
        );
    }

    public void fillStatement(SdNodeDefinition sdNode, NodeEntity nodeEntity, PreparedStatement statement) throws SQLException {
        RelationShipRdbTable relation = this.getRdbNodeMapping(sdNode.getNodeName());
        // 字段名称
        List<String> columnNames = Lists.newArrayList(relation.getColumn().values());
        Collections.sort(columnNames);

        for (Map.Entry<String, String> propColumn : relation.getColumn().entrySet()) {
            String propName = propColumn.getKey();
            String columnName = propColumn.getValue();

            int index = columnNames.indexOf(columnName) + 1;
            SdProperty prop = sdNode.getProp().get(propName);
            if (prop == null) {
                prop = UXDFLoader.getSd().getNode().getAttr().get(propName);
            }
            if (!nodeEntity.containsKey(propName) || nodeEntity.get(propName) == null) {
                statement.setNull(index, Types.NULL);
                continue;
            }
            switch (prop.getBase()) {
                case Binary:
                    break;
                case String:
                    statement.setString(index, nodeEntity.getString(propName));
                    break;
                case Float:
                    statement.setFloat(index, nodeEntity.getFloat(propName));
                    break;
                case Boolean:
                    statement.setBoolean(index, nodeEntity.getBoolean(propName));
                    break;
                case Integer:
                    statement.setInt(index, nodeEntity.getIntValue(propName));
                    break;
                case Datetime:
                    statement.setDate(index, nodeEntity.getSqlDate(propName));
                    break;
            }
        }
    }

    public void fillStatement(SdEventDefinition sdEvent, EventEntity eventEntity, PreparedStatement statement) throws SQLException {
        RelationShipRdbTable relation = this.getRdbEventMapping(
                sdEvent.getEventName(),
                sdEvent.getLeftNodeName(),
                sdEvent.getRightNodeName()
        );
        // 字段名称
        List<String> columnNames = Lists.newArrayList(relation.getColumn().values());
        Collections.sort(columnNames);

        for (Map.Entry<String, String> propColumn : relation.getColumn().entrySet()) {
            String propName = propColumn.getKey();
            String columnName = propColumn.getValue();

            int index = columnNames.indexOf(columnName) + 1;
            SdProperty prop = sdEvent.getProp().get(propName);
            if (prop == null) {
                prop = UXDFLoader.getSd().getEvent().getAttr().get(propName);
            }
            if (!eventEntity.containsKey(propName) || eventEntity.get(propName) == null) {
                statement.setNull(index, Types.NULL);
                continue;
            }
            switch (prop.getBase()) {
                case Binary:
                    break;
                case String:
                    statement.setString(index, eventEntity.getString(propName));
                    break;
                case Float:
                    statement.setFloat(index, eventEntity.getFloat(propName));
                    break;
                case Boolean:
                    statement.setBoolean(index, eventEntity.getBoolean(propName));
                    break;
                case Integer:
                    statement.setInt(index, eventEntity.getIntValue(propName));
                    break;
                case Datetime:
                    statement.setDate(index, eventEntity.getSqlDate(propName));
                    break;
            }
        }
    }
}
